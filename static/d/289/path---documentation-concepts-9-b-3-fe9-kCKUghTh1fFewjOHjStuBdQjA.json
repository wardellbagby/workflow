{"data":{"markdownRemark":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"Concepts"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Workflows provide a way to build complex applications out of small, isolated pieces with a predictable data flow and a consistent API contract. They are conceptually similar to components in architecture patterns such as React (though they are fully native and type-safe)."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"em","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Note:"}]},{"type":"text","value":" One important difference between workflows and components found in web frontend frameworks comes from the vast differences between the DOM and native UI paradigms (iOS/Android). The DOM is already declarative (meaning that we can always reason about the element tree in a web page). UIKit, for is not – it very much relies on a procedural programming model where transitions are performed by imperative methods like "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"push"}]},{"type":"text","value":", "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"fadeOut"}]},{"type":"text","value":", etc. For this reason, workflows do not ever refer directly to views. They are instead responsible for rendering view models. This view model can then be used to update the UI."}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Workflow is cross-platform"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"While specific APIs differ between Swift and Kotlin, the Workflow library shares all of the same conceptual pieces on both platforms. This is extremely beneficial when building cross-platform software, as the same design (though not the same code) can be used for both Swift and Kotlin. Build a feature on one platform first? That code now serves as an excellent reference when implementing the same functionality on the other platform."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"The Role of a Workflow"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Workflow"}]},{"type":"text","value":" is a protocol (in Swift) and interface (in Kotlin) that defines the contract for a single node in the workflow hierarchy."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-swift"]},"children":[{"type":"text","value":"public protocol Workflow: AnyWorkflowConvertible {\n\n    associatedtype State\n\n    associatedtype Output = Never\n\n    associatedtype Rendering\n\n    func makeInitialState() -> State\n\n    func workflowDidChange(from previousWorkflow: Self, state: inout State)\n\n    func compose(state: State, context: WorkflowContext<Self>) -> Rendering\n\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-kotlin"]},"children":[{"type":"text","value":"interface Workflow<in I : Any, S : Any, out O : Any, out R : Any> {\n\n  fun initialState(input: I): S\n\n  fun onInputChanged(\n    old: I,\n    new: I,\n    state: S\n  ): S = state\n\n  fun compose(\n    input: I,\n    state: S,\n    context: WorkflowContext<S, O>\n  ): R\n\n  fun snapshotState(state: S): Snapshot\n  fun restoreState(snapshot: Snapshot): S\n\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Workflows have several responsibilities:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Workflows have state"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Every Workflow implementation defines a "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"State"}]},{"type":"text","value":" type to maintain any necessary state while the workflow is running."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"For example, a tic-tac-toe game might have a state like this:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-swift"]},"children":[{"type":"text","value":"struct State {\n\n    enum Player {\n        case x\n        case o\n    }\n\n    enum Space {\n        case unfilled\n        filled(Player)\n    }\n\n    // 3 rows * 3 columns = 9 spaces\n    var spaces: [Space] = Array(repeating: .unfilled, count: 9)\n    var currentTurn: Player = .x\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"When the workflow is first started, it is queried for an initial state value. From that point forward, the workflow may advance to a new state as the result of events occurring from various sources (which will be covered below)."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Workflows produce an external representation of their state via "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Rendering"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Immediately after starting up, or after a state transition occurs, a workflow will have its "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"compose(state:context:)"}]},{"type":"text","value":" method called. This method is responsible for creating and returning a value of type "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Rendering"}]},{"type":"text","value":". You can think of "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Rendering"}]},{"type":"text","value":" as the \"external state\" of the workflow. While a workflow's internal state may contain more detailed or comprehensive state, the "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Rendering"}]},{"type":"text","value":" (external state) is a type that is useful outside of the workflow."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"When building an interactive application, the "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Rendering"}]},{"type":"text","value":" type is commonly (but not always) a view model that will drive the UI layer."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Workflows form a hierarchy (they may have children)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"As they produce a "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Rendering"}]},{"type":"text","value":" value, it is common for workflows to delegate some portion of that work to a "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"child workflow"}]},{"type":"text","value":". This is also done via the "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"ComponentContext"}]},{"type":"text","value":" that is passed into the "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"compose"}]},{"type":"text","value":" method. In order to delegate to a child, the parent workflow instantiates the child within the "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"compose"}]},{"type":"text","value":" method. The parent then calls "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"compose"}]},{"type":"text","value":" on the context, with the child workflow as the single argument. The infrastructure will spin up the child workflow (including initializing its initial state) if this is the first time this child has been used, or, if the child was also used on the previous "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"compose"}]},{"type":"text","value":" pass, the existing child will be updated. Either way, "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"compose"}]},{"type":"text","value":" will ultimately be called on the child (by the Workflow infrastructure), and the resulting "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Child.Rendering"}]},{"type":"text","value":" value will be returned to the parent."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"This allows a parent to return complex "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Rendering"}]},{"type":"text","value":" types (such as a view model representing the entire UI state of an application) without needing to model all of that complexity within a single workflow."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Workflows can respond to UI events"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"WorkflowContext"}]},{"type":"text","value":" that is passed into "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"compose"}]},{"type":"text","value":" as the second parameter provides some useful tools to assist in creating the "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Rendering"}]},{"type":"text","value":" value. "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If a workflow is producing a view model, it is common to need an event handler to respond to UI events. The "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"WorkflowContext"}]},{"type":"text","value":" has API to create an event handler that, when called, will advance the workflow by dispatching an action back to the workflow."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Workflows can subscribe to external event sources"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If a workflow needs to respond to some external event source (e.g. push notifications), the workflow can ask the context to listen to those events from within the "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"compose"}]},{"type":"text","value":" method."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Workflows can perform asynchronous tasks (Workers)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Workers"}]},{"type":"text","value":" are very similar in concept to child workflows. Unlike child workflows, however, workers do not have a "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Rendering"}]},{"type":"text","value":" type; they only exist to perform a single asynchronous task before sending an output event back up the tree to their parent."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"A workflow can ask the infrastructure to await the result of a worker by handing that worker to the context within a call to the "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"compose"}]},{"type":"text","value":" method."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Workflows are advanced by "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Action"}]},{"type":"text","value":"s"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Any time something happens that should advance a workflow – a UI event, a network response, a child's output event – actions are used to perform the update. For example, a workflow may respond to UI events by mapping those events into a type conforming to "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"WorkflowAction"}]},{"type":"text","value":". These types implement the logic to advance a workflow by:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Advancing to a new state"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"(Optionally) emitting an output event up the tree."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Workflows can emit output events up the hierarchy to their parent"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"When a workflow is advanced by an action, an optional output event can be sent up the workflow hierarchy. This is the opportunity for a workflow to notify its parent that something has happened (and the parent's opportunity to respond to that event by dispatching its own action, continuing up the tree as long as output events are emitted)."}]}],"data":{"quirksMode":false}},"frontmatter":{"navigation":{"visible":true,"path":"documentation"},"title":"Concepts"}}},"pageContext":{"title":"Concepts","index":1,"slug":"/documentation/concepts/"}}